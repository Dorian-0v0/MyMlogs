## MySQL和redis数据同步（双写一致性）

很难保证一致性，每种方法都有缺点和优点，如果一定要一致就用读锁和写锁，然后的话对于常规且一致性要求不是特别的高业务就用**缓存旁路模式**或延时双删。

我项目里用的是AOP加缓存旁路模式。

数据不一致一般出现在数据变更的时候，**由于要操作数据库和redis缓存，无法保证原子性**，所以在并发的情况下就容易出现俩数据库的数据不一致。

### Cache Aside Pattern（缓存旁路模式）

**写操作**：先操作数据库，后修改或删除缓存
**读操作**：先读缓存，没命中就数据库，然后同步到缓存
**优点**：实现和原理简单，可以解决大部分场景，适合读多写少，一致性要求不高的情况
**缺点**：高并发的情况下修改完数据库但没操作redis会导致其他线程短时间段内读取到修改前的数据。此外如果删除缓存的话之后读操作读取一些热点数据会出现缓存击穿，缓存穿透，缓存雪崩等问题，就是大量请求同时去请求数据库来获取数据。

### 延迟双删

先删除缓存然后更新数据库，然后延迟几百毫秒或几秒，再删除缓存
**双删的目的：防止脏数据到缓存里**
**延迟的目的：db主从同步需要一些时间，如果立即删除redis数据 。那么并发读取可能会读到db从库的旧数据，然后更新redis为旧的数据。**
缺点就是会阻塞（可以使用消息队列来异步实现，但又要考虑可靠性），所以发送响应就会慢

### 先更新缓存，再同步或异步更新数据库

可以解决绝大多数缓存不一致问题 但是在高并发的情况下同步更新会出现如果一个线程修改缓存和数据库的时间间隔内另外一个线程正好完成了修改缓存和数据库的操作，这样会出现缓存不一致
异步的话就是通过消息队列，先删除缓存然后发一条消息给消息队列然后异步操作数据库，可能会有延迟，延迟期间MySQL和redis不一致，这就要考虑消息队列的可靠性以及并发情况下发送消息的先后顺序。

## redis为什么这么快

1. redis基于内存，避免磁盘的IO
2. 单线程，减少多线程的开销（因为多线程会涉及到锁）。
3. 高效的数据结构（跳表）
## redis的双写一致性（即缓冲和数据库里的数据保持一致）
- 涉及到写操作：延迟双删（**修改数据库表之前和之后都删除缓存，为了防止修改数据库又有读操作导致脏读，使得脏数据写入redis**）
  ### redis数据删除策略
  - 定期删除：设置每次删除的时间间隔
  - key过期再次查询redis发现为null再删除（没查询之前有大量key存在，浪费内存）
  ### 数据淘汰策略（redis里内存满了所采取的策略）
  - 默认为不写入新的数据
  - allkey-lru策略：利用lru算法，它会优先删除最近最少访问的键。
  - 随机淘汰
  - 优先删除那些即将过期的键。
## RDB和AOF(可在redis.conf中配置)
**RDB：快照式持久化，在指定时间间隔内生成一个二进制快照文件**<br>
**AOF：日志式持久文件，记录所有写操作命令**
| 特性        | RDB              | AOF                |
|-----------|------------------|--------------------|
| 持久化方式   | 定时快照           | 记录每个写操作        |
| 文件大小    | 小(二进制压缩)     | 大(文本命令)         |
| 恢复速度    | 快               | 慢                 |
| 数据安全性  | 可能丢失较多数据    | 根据配置可做到几乎不丢失 |
| 性能影响    | 低               | 较高                |
## Redisson分布式锁
分布式锁的特点
1. 互斥性：同一时刻只有一个客户端能持有锁
2. 可重入性：一个线程已经持有了某个锁，它可以再次尝试获取同一个锁，释放锁的时候要释放两把锁
3. 超时时间：线程获取锁后会有看门狗线程监视该线程，如果设置了锁的超时时间，但线程仍在执行操作未释放锁，Redisson 的 Watchdog（看门狗）机制会自动延长锁的过期时间。
4. 

分布式锁底层是redis的setnx命令以及Redis 的 Lua 脚本功能，可以确保锁的获取和释放操作是原子性的。
